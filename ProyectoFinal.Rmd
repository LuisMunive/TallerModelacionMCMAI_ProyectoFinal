---
title: "Proyecto Final. Taller de Modelación Matemática I. MCMAI"
author: "Rodrigo Zúñiga Trejo & Luis Ramón Munive Hernández"
date: "Mayo 6, 2021"
output:
  pdf_document: default
header-includes: \usepackage{float}
---

\textbf{Problema-1}: El siguiente conjunto de datos representa la \textit{dirección} (ángulos $\theta_i$) que tomaron 76 tortugas después de depositar sus huevos en alguna costa de Guerrero. Los biólogos encargados del estudio desean hacer inferencias sobre la población de tortugas que depositan sus huevos en estas costas. En particular, desean describir el comportamiento de estos datos a través de un modelo estadístico que les permita hacer conclusiones probabilísticas sobre toda la población con base en esta muestra de registros. Los datos en ángulos se muestran en la siguiente Tabla, su representación gráfica se muestra en la Figura 1.

\begin{table}[H]
\begin{center}
\begin{tabular}{rrrrrrrrrrr}
\hline
8 & 27 & 45 & 53 & 64 & 73 & 88 & 96 & 138 & 226 & 257 \\
9 & 30 & 47 & 56 & 64 & 78 & 88 & 98 & 153 & 237 & 268 \\
13 & 34 & 48 & 57 & 64 & 78 & 90 & 100 & 153 & 238 & 285 \\
13 & 38 & 48 & 58 & 65 & 78 & 92 & 103 & 155 & 243 & 319 \\
14 & 38 & 48 & 58 & 65 & 83 & 92 & 106 & 204 & 244 & 343 \\
18 & 40 & 48 & 61 & 68 & 83 & 93 & 113 & 215 & 250 & 350 \\
22 & 44 & 50 & 63 & 70 & 88 & 95 & 118 & 223 & 251 & \\
\hline
\end{tabular}
\end{center}
\end{table}

```{r fig.align='center', message=FALSE, echo=FALSE, fig.cap="Direcciones de 76 tortugas, después de depositar sus huevos en la playa."}
library(CircStats)
angulosTortugas <- c(8, 27, 45, 53, 64, 73, 88, 9, 30, 47, 56, 64, 78, 88,
                    13, 34, 48, 57, 64, 78, 90, 13, 38, 48, 58, 65, 78, 92,
                    14, 38, 48, 58, 65, 83, 92, 18, 40, 48, 61, 68, 83, 93,
                    22, 44, 50, 63, 70, 88, 95, 96, 138, 226, 257, 98, 153,
                    237, 268, 100, 153, 238, 285, 103, 155, 243, 319, 106,
                    204, 244, 343, 113, 215, 250, 350, 118, 223, 251)
angulosTortugasRad <- angulosTortugas * pi / 180
circ.plot(x = angulosTortugasRad, stack = TRUE, bins = 23, shrink = 1.5, dotsep = 20, 
          main = "Datos de Tortugas")
```

```{r}
##### Kernel de la densidad de Y = log R dado theta y mu #####
kerY <- function(y, theta, mu) {
  b <- mu[1] * cos(theta) + mu[2] * sin(theta)
  return(exp(-0.5 * (exp(2 * y) - 2 * b * exp(y)) + 2 * y))
}
##### Funciones para calcular los valores iniciales  de la distribución #####
##### Normal que se usará como distribución de transición #####
media0 <- function(theta, mu){
  b <- mu[1] * cos(theta) + mu[2] * sin(theta)
  return(log(b / 2 + sqrt(b^2 + 8) / 2))
}
var0 <- function(theta, mu){
  b <- mu[1] * cos(theta) + mu[2] * sin(theta)
  return(2 / (b^2 + b * sqrt(b^2 + 8) + 8))
}

##### Algoritmo Metropolis-Hastings #####

MetroHast <- function(f, theta, mu, burn, ite.inter, lag, tmues, Ncadenas){
  # La función Metro-Hast obtiene el promedio de todos los valores de la cadena. 
  # Elimina el periodo de calentamiento, considera los saltos (lag) y promedia.
  # Es decir, arroja el promedio de las muestra sin calentamiento y considerando el lag
  # Author: Gabriel N
  # Modificado por: Rodrigo Zúñiga Trejo & Luis Ramón Munive Hernández
  # Date: Abril 2021.
  N <- Ncadenas # Número de cadenas a simular
  ite <- burn + ite.inter + lag * tmues # Número total de iteraciones
  burn.tot <- burn + ite.inter # Número total de iteraciones de calentamiento
  
  m0 <- media0(theta, mu) # Medía para las simulaciones de una Normal
  v0 <- var0(theta, mu) # Varianza para las simulaciones de una Normal

  y0 <- rnorm(N, m0, sqrt(v0)) # Valores de arranque para las cadenas
  
  y <- matrix(NA, nrow = tmues, ncol = N, byrow = TRUE) # Matriz para guardar las simulaciones 
                                                     # en cada iteración de todas las cadenas
  n.sample <- 1 # Contador para guardar las simulaciones de la muestra sin burn-in y con lag
  
  # Iteraciones del algoritmo
  for (j in 1 : ite){
    y1 <- rnorm(N, m0, sqrt(v0))
    w1 <- f(y1, theta, mu) / dnorm(y1, m0, sqrt(v0))
    w0 <- f(y0, theta, mu) / dnorm(y0, m0, sqrt(v0))
    alpha <- w1 / w0
    u <- runif(N, 0, 1)
    aux <- ifelse(u <= alpha, y1, y0)
    y0 <- aux
    if(j > burn.tot & ( j %% lag) == 0){
      y[n.sample, ] <- exp(y0)
      n.sample <- n.sample + 1
    }
  }
  A <- apply(y, MARGIN = 2, FUN = mean) # Promedios de las cadenas considerando la muestra final
  drop(A)
  #drop(y) # Regresa todas las cadenas simuladas
}

##### Algoritmo Metropolis-Hastings dentro Gibbs #####

MHdentroGibbs <- function(theta, N, burn.G, ite.inter.G, lag.G){
  n <- length(theta) # Número de datos
  
  ite <- burn.G + ite.inter.G + lag.G * N # Número total de iteraciones
  Tburn <- burn.G + ite.inter.G # Número total de iteraciones de calentamiento
  
  lambda1_0 <- 0.001 # Hiperparámetro de la distribución inicial para el vector mu
  lambda2_0 <- 0.001 # Hiperparámetro de la distribución inicial para el vector mu
  
  lambda1_n <- lambda1_0 + n # Hiperparámetro de la distribución final para el vector mu
  lambda2_n <- lambda2_0 + n # Hiperparámetro de la distribución final para el vector mu
  
  mu1 <- rep(0, N) # Vector para guardar las simulaciones de mu1
  mu2 <- rep(0, N) # Vector para guardar las simulaciones de mu2
  r <- matrix(data = 1, nrow = N, ncol = n, byrow = TRUE) # Matriz para guardar las simulaciones de r_i
  
  cont <- 1 # Contador usado en la obtención de la muestra final sin burn-in y con lag
  muaux1 <- 0 # Variable auxiliar en el algoritmo para guardar valores de mu1 en cada iteración
  muaux2 <- 0 # Variable auxiliar en el algoritmo para guardar valores de mu2 en cada iteración
  raux <- rep(1, n) # Vector auxiliar en el algoritmo para guardar valores de r_i en cada iteración
  
  for(i in 2 : ite + 1){
      muaux1 <- rnorm(1, mean = lambda1_n^(-1) * (lambda1_0 * muaux1 + n * mean(raux * cos(theta))),
                      sd = 1 / sqrt(lambda1_n))
      muaux2 <- rnorm(1, mean = lambda2_n^(-1) * (lambda2_0 * muaux2 + n * mean(raux * sin(theta))),
                      sd = 1 / sqrt(lambda2_n))
      #raux <- MetroHast(f = kerY, theta = theta, mu = c(muaux1, muaux2), burn = 5000, ite.inter = 2500,
      #                  lag = 30, tmues = 500, Ncadenas = n)     # Estos parámetros fueron para la prueba
      raux <- MetroHast(f = kerY, theta = theta, mu = c(muaux1, muaux2), burn = 7500, ite.inter = 2500,
                        lag = 30, tmues = 100, Ncadenas = n)
      if(i > Tburn & (i %% lag.G) == 0){
          mu1[cont] <- muaux1
          mu2[cont] <- muaux2
          r[cont, ] <- raux
          cont <- cont + 1
      }
  }
  return(list(mu1, mu2, r))
}
```

```{r, eval=FALSE, echo=FALSE}
### Prueba para analizar convergencia y autocorrelación en el algoritmo Metropolis-Hastings
set.seed(29042021)
tiempoInicioPMH <- Sys.time()
pruebaMH <- MetroHast(f = kerY, theta = angulosTortugasRad, mu = c(0, 0), burn = 0, ite.inter = 0, lag = 1, tmues = 30000, Ncadenas = length(angulosTortugasRad))
tiempoFinPMH <- Sys.time()
tiempoEjecPMH <- tiempoFinPMH - tiempoInicioPMH
tiempoEjecPMH
```

```{r, eval=FALSE, echo=FALSE}
### Muestra aleatoria para analizar 5 r_i
set.seed(29042021)
sort(sample(x = c(1:76), size = 5, replace = FALSE))
```

```{r, eval=FALSE, echo=FALSE}
# Gráficas de promedios ergódicos de los parámetros obtenidos del algoritmo Metropolis-Hastings
library(latex2exp)

plot(cumsum(pruebaMH[,5]) / c(1:dim(pruebaMH)[1]), type = "l", main = TeX("Promedios ergódicos de $r_{5}$ en Metropolis-Hastings"), xlab = "Iteraciones", ylab = TeX("$r_{5}$"), las = 1)

plot(cumsum(pruebaMH[,24]) / c(1:dim(pruebaMH)[1]), type = "l", main = TeX("Promedios ergódicos de $r_{24}$ en Metropolis-Hastings"), xlab = "Iteraciones", ylab = TeX("$r_{24}$"), las = 1)

plot(cumsum(pruebaMH[,25]) / c(1:dim(pruebaMH)[1]), type = "l", main = TeX("Promedios ergódicos de $r_{25}$ en Metropolis-Hastings"), xlab = "Iteraciones", ylab = TeX("$r_{25}$"), las = 1)

plot(cumsum(pruebaMH[,52]) / c(1:dim(pruebaMH)[1]), type = "l", main = TeX("Promedios ergódicos de $r_{52}$ en Metropolis-Hastings"), xlab = "Iteraciones", ylab = TeX("$r_{52}$"), las = 1)

plot(cumsum(pruebaMH[,72]) / c(1:dim(pruebaMH)[1]), type = "l", main = TeX("Promedios ergódicos de $r_{72}$ en Metropolis-Hastings"), xlab = "Iteraciones", ylab = TeX("$r_{72}$"), las = 1)

# Autocorrelogramas

acf(pruebaMH[,5], main = TeX("Autocorrelograma para $r_{5}$ en Metropolis-Hastings"), lag.max = 100, las = 1)

acf(pruebaMH[,24], main = TeX("Autocorrelograma para $r_{24}$ en Metropolis-Hastings"), lag.max = 100, las = 1)

acf(pruebaMH[,25], main = TeX("Autocorrelograma para $r_{25}$ en Metropolis-Hastings"), lag.max = 100, las = 1)

acf(pruebaMH[,52], main = TeX("Autocorrelograma para $r_{52}$ en Metropolis-Hastings"), lag.max = 100, las = 1)

acf(pruebaMH[,72], main = TeX("Autocorrelograma para $r_{72}$ en Metropolis-Hastings"), lag.max = 100, las = 1)
```



```{r, eval=FALSE, echo=FALSE}
### Prueba para analizar convergencia y autocorrelación en el algoritmo Metropolis-Hastings dentro Gibbs
### promediando la muestra obtenida de 500 con un lag de 30 en cada iteración de Metropolis-Hastings
set.seed(27042021)
tiempoInicioMHdentroG <- Sys.time()
pruebaMHdentroG <- MHdentroGibbs(theta = angulosTortugasRad, N = 10000, burn.G = 0, ite.inter.G = 0, lag = 1)
tiempoFinMHdentroG <- Sys.time()
tiempoEjecMHdentroG <- tiempoFinMHdentroG - tiempoInicioMHdentroG
tiempoEjecMHdentroG
```

```{r, eval=FALSE, echo=FALSE}
### Escribir archivos con los datos obtenidos de la prueba para el algoritmo Metropolis-Hastings dentro Gibbs
write.csv(x = pruebaMHdentroG[[1]], file="mu1.csv")
write.csv(x = pruebaMHdentroG[[2]], file="mu2.csv")
write.csv(x = pruebaMHdentroG[[3]], file="r.csv")
write.csv(x = tiempoEjecMHdentroG, file = "tiempoEjecución.csv")
```

```{r, eval=FALSE, echo=FALSE}
# Gráficas de promedios ergódicos de los parámetros obtenidos del algoritmo Metropolis-Hastings dentro Gibbs
plot(cumsum(pruebaMHdentroG[[1]]) / c(1:length(pruebaMHdentroG[[1]])), type = "l", main = TeX("Promedios ergódicos de $\\mu_1$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$\\mu_1$"), las = 1)

plot(cumsum(pruebaMHdentroG[[2]]) / c(1:length(pruebaMHdentroG[[1]])), type = "l", main = TeX("Promedios ergódicos de $\\mu_2$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$\\mu_2$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,5]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{5}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{5}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,24]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{24}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{24}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,25]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{25}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{25}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,52]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{52}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{52}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,72]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{72}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{72}$"), las = 1)

# Autocorrelogramas

acf(pruebaMHdentroG[[1]], main = TeX("Autocorrelograma para $\\mu_1$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[2]], main = TeX("Autocorrelograma para $\\mu_2$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,5], main = TeX("Autocorrelograma para $r_{5}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,24], main = TeX("Autocorrelograma para $r_{24}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,25], main = TeX("Autocorrelograma para $r_{25}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,52], main = TeX("Autocorrelograma para $r_{52}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,72], main = TeX("Autocorrelograma para $r_{72}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)
```



```{r, eval=FALSE, echo=FALSE}
### Ejecución para obtener la muestra de 1000 mu_1 y mu_2 con el algoritmo Metropolis-Hastings dentro Gibbs
set.seed(27042021)
tiempoInicioMHdentroG <- Sys.time()
pruebaMHdentroG <- MHdentroGibbs(theta = angulosTortugasRad, N = 1000, burn.G = 1500, ite.inter.G = 500, lag = 5)
tiempoFinMHdentroG <- Sys.time()
tiempoEjecMHdentroG <- tiempoFinMHdentroG - tiempoInicioMHdentroG
tiempoEjecMHdentroG
```

```{r, eval=FALSE, echo=FALSE}
### Escribir archivos con los datos obtenidos de la prueba para el algoritmo Metropolis-Hastings dentro Gibbs
write.csv(x = pruebaMHdentroG[[1]], file="mu1.csv")
write.csv(x = pruebaMHdentroG[[2]], file="mu2.csv")
write.csv(x = pruebaMHdentroG[[3]], file="r.csv")
write.csv(x = tiempoEjecMHdentroG, file = "tiempoEjecución.csv")
```

```{r, eval=FALSE, echo=FALSE}
# Gráficas de promedios ergódicos de los parámetros obtenidos del algoritmo Metropolis-Hastings dentro Gibbs
plot(cumsum(pruebaMHdentroG[[1]]) / c(1:length(pruebaMHdentroG[[1]])), type = "l", main = TeX("Promedios ergódicos de $\\mu_1$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$\\mu_1$"), las = 1)

plot(cumsum(pruebaMHdentroG[[2]]) / c(1:length(pruebaMHdentroG[[1]])), type = "l", main = TeX("Promedios ergódicos de $\\mu_2$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$\\mu_2$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,5]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{5}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{5}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,24]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{24}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{24}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,25]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{25}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{25}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,52]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{52}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{52}$"), las = 1)

plot(cumsum(pruebaMHdentroG[[3]][,72]) / c(1:dim(pruebaMHdentroG[[3]])[1]), type = "l", main = TeX("Promedios ergódicos de $r_{72}$ en M-H dentro Gibbs"), xlab = "Iteraciones", ylab = TeX("$r_{72}$"), las = 1)

# Autocorrelogramas

acf(pruebaMHdentroG[[1]], main = TeX("Autocorrelograma para $\\mu_1$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[2]], main = TeX("Autocorrelograma para $\\mu_2$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,5], main = TeX("Autocorrelograma para $r_{5}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,24], main = TeX("Autocorrelograma para $r_{24}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,25], main = TeX("Autocorrelograma para $r_{25}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,52], main = TeX("Autocorrelograma para $r_{52}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)

acf(pruebaMHdentroG[[3]][,72], main = TeX("Autocorrelograma para $r_{72}$ en M-H dentro Gibbs"), lag.max = 30, las = 1)
```

```{r}
hist(pruebaMHdentroG[[1]], probability = TRUE, col = "black", border = "white", main = TeX("Histograma de la muestra de $\\mu_1$"), xlab = TeX("$\\mu_1$"))

hist(pruebaMHdentroG[[2]], probability = TRUE, col = "black", border = "white", main = TeX("Histograma de la muestra de $\\mu_2$"), xlab = TeX("$\\mu_2$"))
```

```{r}
library(HDInterval)
hist(x = pruebaMHdentroG[[1]], probability = TRUE, col = "black", border = "white", main = TeX("Histograma de la muestra de $\\mu_1$"), xlab = TeX("$\\mu_1$"))
abline(v = hdi(pruebaMHdentroG[[1]])[[1]], col = "red", lwd = 3, lty = 2)
abline(v = hdi(pruebaMHdentroG[[1]])[[2]], col = "red", lwd = 3, lty = 2)
```

```{r}
hist(x = pruebaMHdentroG[[2]], probability = TRUE, col = "black", border = "white", main = TeX("Histograma de la muestra de $\\mu_2$"), xlab = TeX("$\\mu_2$"))
abline(v = hdi(pruebaMHdentroG[[2]])[[1]], col = "red", lwd = 3, lty = 2)
abline(v = hdi(pruebaMHdentroG[[2]])[[2]], col = "red", lwd = 3, lty = 2)
```

```{r}
### Muestreando de la distribución predictiva del ángulo aleatorio theta
predTheta <- function(mu1, mu2){
  n <- length(mu1)
  x1 <- rep(NA, n)
  x2 <- rep(NA, n)
  theta <- rep(NA, n)
  for(i in 1 : length(pruebaMHdentroG[[1]])){
    x1[i] <- rnorm(n = 1, mean = mu1[i], sd = 1)
    x2[i] <- rnorm(n = 1, mean = mu2[i], sd = 1)
    theta[i] <- atan2(x2[i], x1[i])
  }
  return(theta)
}
```

```{r}
muestraTheta <- predTheta(pruebaMHdentroG[[1]], pruebaMHdentroG[[2]])

muestraThetaPositivos <- c(muestraTheta[which(muestraTheta > 0)], muestraTheta[which(muestraTheta < 0)] + 2 * pi )
```

```{r}
hist(x = muestraThetaPositivos, probability = TRUE, col = "black", border = "white", main = TeX("Histograma de la muestra de $\\theta_{n+1}$"), xlab = TeX("$\\theta$"))
```

```{r}
circ.plot(x = muestraThetaPositivos, stack = TRUE, bins = 23, shrink = 1.5, dotsep = 200, 
          main = TeX("Muestra de $\\theta_{n+1}$"))
rose.diag(x = muestraThetaPositivos, bins = 23, shrink = 1.5, prop = 2.1)
```

